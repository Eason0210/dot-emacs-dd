#+AUTHOR: Doug Davis
#+STARTUP: indent

* Startup

#+begin_src emacs-lisp :results silent
  ;; Use .el if it is newer
  (when (boundp 'load-prefer-newer)
    (setq load-prefer-newer t))

  (when (or (eq system-type 'darwin)
            (eq system-type 'gnu/linux))
    (setq default-directory "~/"))

  (fset 'yes-or-no-p 'y-or-n-p)

  ;; this init.el file is designed to be a symlink to the init.el file
  ;; in my `emacs.d` git repo.  this ensures the git repo can live
  ;; anywhere
  (add-to-list 'load-path (directory-file-name
                           (file-name-directory
                            (file-truename
                             (concat user-emacs-directory "init.el")))))

  (setq custom-file (concat user-emacs-directory "custom.el"))

  (setq user-mail-address "ddavis@ddavis.io"
        user-login-name "ddavis"
        user-full-name "Doug Davis")
#+end_src

* Variables

#+begin_src emacs-lisp :results silent
  (defconst ddavis-v-is-mac (eq system-type 'darwin)
    "true if on a Mac")

  (defconst ddavis-v-is-cc7 (string= (system-name) "cc7")
    "true if on cc7 box")

  (defconst ddavis-v-is-grads-18 (string= (system-name) "grads-18.internal.phy.duke.edu")
    "true if on grads-18 Duke physics machine")

  (defconst ddavis-v-is-dobian (string= (system-name) "dobian")
    "true if on dobian box")

  (defconst ddavis-v-is-linux-desktop (or nil ddavis-v-is-cc7)
    "true if personal linux desktop")

  (defconst ddavis-v-enable-mu4e
    (or ddavis-v-is-mac
        ddavis-v-is-cc7
        ddavis-v-is-grads-18)
    "a flag for conditionally setting up mu4e stuff")

  (defconst ddavis-v-enable-irc
    (or ddavis-v-is-mac
        ddavis-v-is-dobian
        ddavis-v-is-grads-18
        ddavis-v-is-cc7)
    "a flag for conditionally setting up erc and circe")

  (defconst ddavis-v-llvm-bin
    (cond (ddavis-v-is-mac "~/Software/LLVM/releases/10.x/bin")
          (ddavis-v-is-cc7 "~/Software/LLVM/releases/master/bin")
          (ddavis-v-is-grads-18 "~/Software/LLVM/releases/master/bin")
          (ddavis-v-is-dobian "/usr/bin"))
    "machine dependent llvm installation path")

  (defconst ddavis-v-clangd-exe
    (if (file-exists-p ddavis-v-llvm-bin)
        (concat (file-name-as-directory ddavis-v-llvm-bin) "clangd")
      nil))

  (defconst ddavis-v-clang-exe
    (if (file-exists-p ddavis-v-llvm-bin)
        (concat (file-name-as-directory ddavis-v-llvm-bin) "clang")
      nil))

  (defconst ddavis-v-clang-format-exe
    (if (file-exists-p ddavis-v-llvm-bin)
        (concat (file-name-as-directory ddavis-v-llvm-bin) "clang-format")
      nil))

  (defconst ddavis-v-rg-exe
    (cond (ddavis-v-is-mac "/usr/local/bin/rg")
          (ddavis-v-is-cc7 "~/.cargo/bin/rg")
          (ddavis-v-is-grads-18 "~/.cargo/bin/rg")
          (ddavis-v-is-dobian "~/.cargo/bin/rg"))
    "machine dependent ripgrep executable string")

  (defconst ddavis-v-fd-exe
    (cond (ddavis-v-is-mac "/usr/local/bin/fd")
          (ddavis-v-is-cc7 "~/.cargo/bin/fd")
          (ddavis-v-is-grads-18 "~/.cargo/bin/fd")
          (ddavis-v-is-dobian "~/.cargo/bin/fd"))
    "machine dependent fd executable string")

  (defconst ddavis-v-sendmail-program
    (cond (ddavis-v-is-mac "~/Software/localbase/bin/msmtp")
          (ddavis-v-is-cc7 "~/Software/localbase/bin/msmtp")
          (ddavis-v-is-grads-18 "/usr/bin/msmtp"))
    "machine dependent msmtp executable string")

  (defconst ddavis-v-mu-exe
    (cond (ddavis-v-is-mac "~/Software/mu/releases/1.3.10/bin/mu")
          (ddavis-v-is-cc7 "/usr/local/bin/mu")
          (ddavis-v-is-grads-18 "~/Software/localbase/bin/mu"))
    "machine dependent mu executable string")

  (defconst ddavis-v-mu4e-dir
    (cond (ddavis-v-is-mac "~/Software/mu/releases/1.3.10/share/emacs/site-lisp/mu4e")
          (ddavis-v-is-grads-18 "~/Software/localbase/share/emacs/site-lisp/mu4e")
          (ddavis-v-is-cc7 "/usr/local/share/emacs/site-lisp/mu4e"))
    "machine dependent mu4e installation location string")
#+end_src

* Package
** Setting up melpa and use-package

#+begin_src emacs-lisp :results silent
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (when (version< emacs-version "27")
    (package-initialize))

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))

  (use-package auto-package-update
    :ensure t
    :config
    (setq auto-package-update-delete-old-versions t
          auto-package-update-interval 5))

  (use-package emacs
    :bind (:map package-menu-mode-map
                ("q" . kill-buffer-and-window)))
#+end_src

** Some local Emacs Lisp

#+begin_src emacs-lisp :results silent
  (use-package random-internet-helpers
    :when ddavis-v-is-mac
    :load-path "~/.emacs.d/site-lisp/"
    :bind ([remap keyboard-quit] . keyboard-quit-context+))
#+end_src

* Exec path

  #+begin_src emacs-lisp :results silent
    (use-package exec-path-from-shell
      :if (memq window-system '(mac ns x))
      :ensure t
      :config
      (exec-path-from-shell-initialize))
  #+end_src

* Utils

#+begin_src emacs-lisp :results silent
  (defun ddavis/enable-cua-selection ()
    "turn on cua-selection-mode"
    (interactive)
    (cua-selection-mode t))

  ;; See the following for more details
  ;;     https://emacs.stackexchange.com/a/50215/8887
  ;; and also see the following on a recent GNU/Linux or similar system:
  ;;     /usr/share/doc/fontconfig/fontconfig-user.html
  ;; for the explanation of spacing=100
  ;; also see the following UNIX StackExchange answer:
  ;;    https://unix.stackexchange.com/a/363368/13105
  (defun ddavis/compare-monospace-font-families ()
    "Display a list of all monospace font faces. Tested on GNU/Linux."
    (interactive)
    (pop-to-buffer "*Monospace Fonts*")
    (erase-buffer)
    (dolist (font-name (seq-filter (lambda (font)
                                     (when-let ((info (font-info font)))
                                       (string-match-p "spacing=100" (aref info 1))))
                                   (font-family-list)))
      (insert
       (propertize
        (concat "1 l; 0 O o [ < = > ] " font-name ")\n")
        'font-lock-face `((:family
                           ,(format "%s" (font-get (font-spec :name font-name) :family))))))))

  (defun ddavis/move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun ddavis/move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (defun ddavis/copy-lines-matching-re (re)
    "put lines matching re in a buffer named *matching*"
    (interactive "sRegexp to match: ")
    (let ((result-buffer (get-buffer-create "*matching*")))
      (with-current-buffer result-buffer
        (erase-buffer))
      (save-match-data
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward re nil t)
            (princ (buffer-substring-no-properties (line-beginning-position)
                                                   (line-beginning-position 2))
                   result-buffer))))
      (pop-to-buffer result-buffer)))

  (defun ddavis/toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+end_src

* Org

#+begin_src emacs-lisp :results silent
  (use-package org
    :ensure t
    :config
    (setq org-src-fontify-natively t)
    (setq org-structure-template-alist
          (append org-structure-template-alist
                  '(("el" . "src emacs-lisp :results silent")
                    ("py" . "src python :results silent")
                    ("cpp" . "src C++")))))

  (use-package org
    :if ddavis-v-is-mac
    :bind (:map org-mode-map
                ("<A-down>" . org-move-subtree-down)
                ("<A-up>" . org-move-subtree-up)
                ("<A-left>" . org-promote-subtree)
                ("<A-right>" . org-demote-subtree)))

  (use-package org
    :unless ddavis-v-is-mac
    :bind (:map org-mode-map
                ("<s-down>" . org-move-subtree-down)
                ("<s-up>" . org-move-subtree-up)
                ("<s-left>" . org-promote-subtree)
                ("<s-right>" . org-demote-subtree)))

  ;; builtin ox packages
  (use-package ox :after org)
  (use-package ox-beamer :after ox)
  (use-package ox-md :after ox)
  ;; some melpa provided ox packages
  (use-package ox-hugo :ensure t :after ox)
  (use-package ox-reveal :ensure t :after ox)
  ;; export syntax highlighting to html
  (use-package htmlize :ensure t)

  ;; (org-babel-do-load-languages
  ;;  'org-babel-load-languages
  ;;  '((python . t)))

  (define-key global-map "\C-ca" 'org-agenda)
  (setq org-agenda-files (list "~/Dropbox/org/agenda/"))
  (setq org-agenda-custom-commands
        '(("c" "Simple agenda view"
           ((agenda "")
            (alltodo "")))))
#+end_src

* Uniquify

#+begin_src emacs-lisp :results silent
  (use-package uniquify
    :config
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
    (setq uniquify-strip-common-suffix t)
    (setq uniquify-after-kill-buffer-p t))
#+end_src

* Looks
** misc

#+begin_src emacs-lisp :results silent
  (setq custom-safe-themes t)
  (global-display-line-numbers-mode)
  (setq column-number-mode t)
#+end_src

** themes

#+begin_src emacs-lisp :results silent
  (defvar ddavis-v-use-gruvbox t
    "t if we want to use gruvbox")
  (defvar ddavis-v-use-local-theme nil
    "t if we want to use the local copy of gruvbox")

  (when ddavis-v-use-gruvbox
    (when (and ddavis-v-use-local-theme
               (package-installed-p 'gruvbox-theme))
      (package-delete (car (cdr (assoc 'gruvbox-theme package-alist)))))

    (unless ddavis-v-use-local-theme
      (unless (package-installed-p 'gruvbox-theme)
        (package-refresh-contents)
        (package-install 'gruvbox-theme)))

    (use-package gruvbox
      :if ddavis-v-use-local-theme
      :load-path "~/.emacs.d/git-repos/emacs-theme-gruvbox"
      :config
      (add-to-list 'custom-theme-load-path "~/.emacs.d/git-repos/emacs-theme-gruvbox")
      (load-theme 'gruvbox t))

    (use-package gruvbox-theme
      :unless ddavis-v-use-local-theme
      :config
      (load-theme 'gruvbox t))

    (set-face-attribute 'link nil :foreground "#458588"))

  ;; (let ((line (face-attribute 'mode-line :underline)))
  ;;   (set-face-attribute 'mode-line           nil :overline   line)
  ;;   (set-face-attribute 'mode-line-inactive  nil :overline   line)
  ;;   (set-face-attribute 'mode-line-inactive  nil :underline  line)
  ;;   (set-face-attribute 'mode-line           nil :box        nil)
  ;;   (set-face-attribute 'mode-line-inactive  nil :box        nil)
  ;;   (set-face-attribute 'mode-line-buffer-id nil :box        nil))
#+end_src

** fonts

#+begin_src emacs-lisp :results silent
  (when window-system
    (when ddavis-v-is-cc7
      (set-face-attribute 'default nil
                          :family "JetBrains Mono"
                          :weight 'medium
                          :height 130))
    (when ddavis-v-is-mac
      (setq mac-allow-anti-aliasing t)
      (set-face-attribute 'default nil
                          :family "JetBrains Mono"
                          :weight 'medium
                          :height 120))
    (when ddavis-v-is-dobian
      (set-face-attribute 'default nil
                          :family "Terminus (TTF)"
                          :weight 'regular
                          :height 90))
    (add-to-list 'default-frame-alist '(height . 72))
    (add-to-list 'default-frame-alist '(width . 234)))
#+end_src

** extend

from https://github.com/emacs-helm/helm/issues/2213; Fix issue with
the new :extend face attribute in emacs-27 Prefer to extend to EOL as
in previous emacs.

#+begin_src emacs-lisp :results silent
  (defun tv/extend-faces-matching (regexp)
    (cl-loop for f in (face-list)
             for face = (symbol-name f)
             when (and (string-match regexp face)
                       (eq (face-attribute f :extend t 'default)
                           'unspecified))
             do (set-face-attribute f nil :extend t)))

  (defun ddavis/init-extend-faces ()
    (when (fboundp 'set-face-extend)
      (with-eval-after-load "mu4e"
        (tv/extend-faces-matching "\\`mu4e"))
      (with-eval-after-load "org"
        (tv/extend-faces-matching "\\`org"))
      (with-eval-after-load "magit"
        (tv/extend-faces-matching "\\`magit"))
      (with-eval-after-load "helm"
        (tv/extend-faces-matching "\\`helm"))))

  (ddavis/init-extend-faces)
#+end_src

* Hydra

#+begin_src emacs-lisp :results silent
  (use-package hydra :ensure t)
  (use-package pretty-hydra :ensure t)
#+end_src

* Projectile

#+begin_src emacs-lisp :results silent
  (use-package projectile
    :ensure t
    :demand t
    :bind-keymap ("C-c P" . projectile-command-map)
    :config
    (setq projectile-track-known-projects-automatically nil
          projectile-globally-ignored-file-suffixes '("#" "~" ".o" ".so" ".elc" ".pyc")
          projectile-globally-ignored-directories '(".git" "__pycache__")
          projectile-globally-ignored-files '(".DS_Store"))
    (projectile-mode))

  (defun ddavis/projectile-proj-find-function (dir)
    (let ((root (projectile-project-root dir)))
      (and root (cons 'transient root))))

  (use-package project
    :config
    (add-to-list 'project-find-functions #'ddavis/projectile-proj-find-function))
#+end_src

** Hydra

#+begin_src emacs-lisp :results silent
  (pretty-hydra-define hydra-projectile (:exit t :hint nil :title (projectile-project-root) :quit-key "q")
    ("Movement" (("b" projectile-switch-to-buffer               "switch")
                 ("B" projectile-switch-to-buffer-other-window  "switch (OW)")
                 ("f" projectile-find-file                      "file")
                 ("F" projectile-find-file-other-window         "file (OW)")
                 ("S" projectile-switch-project                 "switch project")
                 ("u" projectile-find-file-in-known-projects    "find in known"))

     "Search" (("r" ddavis/helm-project-search                  "ripgrep (helm)")
               ("s" ddavis/ripgrep-proj-or-dir                  "ripgrep (rg.el)")
               ("o" projectile-multi-occur                      "multioccur"))

     "Misc" (("a" projectile-add-known-project                  "add to known")
             ("i" projectile-ibuffer                            "ibuffer")
             ("k" projectile-kill-buffers                       "Kill em"))))

  (define-key projectile-mode-map (kbd "C-c p") 'hydra-projectile/body)
#+end_src

* Helm

#+begin_src emacs-lisp :results silent
  (use-package helm
    :ensure t
    :init (setq helm-autoresize-max-height 50
                helm-autoresize-min-height 30)
    :bind (("C-x C-f" . helm-find-files)
           ("C-x C-t" . find-file)
           ("C-x r b" . helm-bookmarks)
           ("C-x m" . helm-M-x)
           ("C-x b" . helm-buffers-list)
           :map helm-map
           ("<tab>" . helm-execute-persistent-action)
           :map helm-command-map
           ("r" . ddavis/helm-project-search))
    :config
    (require 'helm-config)
    (setq helm-split-window-in-side-p t
          helm-split-window-default-side 'below
          helm-idle-delay 0.0
          helm-input-idle-delay 0.01
          helm-quick-update t
          helm-ff-skip-boring-files t)
    (helm-autoresize-mode 1)
    (helm-mode 1))
#+end_src

** Helm searching

A nice [[https://www.manueluberti.eu/emacs/2020/02/22/ripgrepping-with-helm/][blog post]] describes how to use ripgrep with pure Helm.

#+begin_src emacs-lisp :results silent
  (setq helm-grep-ag-command (concat ddavis-v-rg-exe
                                     " --color=always"
                                     " --smart-case"
                                     " --no-heading"
                                     " --line-number %s %s %s")
        helm-grep-file-path-style 'relative)

  (defun ddavis/helm-rg (directory &optional with-types)
    "Search in DIRECTORY with ripgrep.
  With WITH-TYPES, ask for file types to search in."
    (interactive "P")
    (require 'helm-adaptive)
    (helm-grep-ag-1 (expand-file-name directory)
                    (helm-aif (and with-types
                                   (helm-grep-ag-get-types))
                        (helm-comp-read
                         "RG type: " it
                         :must-match t
                         :marked-candidates t
                         :fc-transformer 'helm-adaptive-sort
                         :buffer "*helm rg types*"))))

  (defun ddavis/helm-project-search (&optional with-types)
    "Search in current project with rippgrep.
  With WITH-TYPES, ask for file types to search in."
    (interactive "P")
    (ddavis/helm-rg (projectile-project-root) with-types))
#+end_src

** Other helm extensions

#+begin_src emacs-lisp :results silent
  (use-package helm-projectile
    :ensure t
    :init (setq projectile-completion-system 'helm
                helm-split-window-in-side-p t)
    :bind (:map helm-command-map
                ("p" . helm-projectile))
    :demand)

  (use-package helm-fd
    :ensure t
    :demand
    :init (setq helm-fd-cmd ddavis-v-fd-exe)
    :bind (:map helm-command-map
                ("/" . helm-fd)
                ("f" . helm-fd-project)))

  (use-package helm-descbinds
    :ensure t
    :demand
    :bind (("C-h b" . helm-descbinds)))
#+end_src

* rg.el

#+begin_src emacs-lisp :results silent
  (use-package rg
    :ensure t
    :after wgrep
    :config
    (setq rg-executable (expand-file-name ddavis-v-rg-exe)
          rg-group-result t
          rg-hide-command t)

    (rg-define-search ddavis/ripgrep-proj-or-dir
      :query ask
      :format regexp
      :files "everything"
      :dir (let ((proj (projectile-project-root)))
             (if proj
                 proj
               default-directory))
      :confirm prefix
      :flags ("--hidden -g !.git")))
#+end_src

* eshell

#+begin_src emacs-lisp :results silent
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((height (/ (window-total-height) 3)))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (insert (concat "ls"))
      (eshell-send-input)))
  (bind-key "C-!" 'eshell-here)

  (defun eshell/clear ()
    (let ((inhibit-read-only t))
      (erase-buffer)))

  (defun eshell/close ()
    (delete-window))
#+end_src

* Company

#+begin_src emacs-lisp :results silent
  (use-package company
    :ensure t
    :hook ((emacs-lisp-mode . company-mode)
           (python-mode . company-mode)
           (mu4e-compoes-mode . company-mode)
           (sh-mode . company-mode)
           (yaml-mode . company-mode)
           (conf-mode . company-mode)
           (lsp-mode . company-mode)
           (LaTeX-mode . company-mode))
    :config
    (setq company-minimum-prefix-length 2)
    (setq company-idle-delay 0.1))
  ;;  (add-to-list 'company-backends 'company-capf))
#+end_src

* Version control

Basically just [[https://magit.vc/][magit]].

#+begin_src emacs-lisp :results silent
  (setq vc-follow-symlinks t)

  (defun ddavis/magit-kill-buffers ()
    "See `https://manuel-uberti.github.io/emacs/2018/02/17/magit-bury-buffer/'"
    (interactive)
    (let ((buffers (magit-mode-get-buffers)))
      (magit-restore-window-configuration)
      (mapc #'kill-buffer buffers)))

  (use-package magit
    :ensure t
    :demand
    :bind (("C-x g" . 'magit-status)
           :map magit-status-mode-map
           ("q" . ddavis/magit-kill-buffers)))
#+end_src

* LSP and Eglot

Configuration for [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] or [[https://github.com/joaotavora/eglot][eglot]].

#+begin_src emacs-lisp :results silent
  (setq read-process-output-max (* 2 1024 1024))

  (use-package lsp-mode
    :ensure t
    :commands lsp
    :init
    (setq lsp-clients-clangd-executable ddavis-v-clangd-exe)
    (setq lsp-prefer-capf t)
    (setq lsp-enable-on-type-formatting nil)
    (setq lsp-auto-guess-root nil))

  (use-package lsp-ui
    :ensure t
    :commands lsp-ui-mode
    :init
    (setq lsp-ui-sideline-show-hover nil))

  (use-package lsp-python-ms :ensure t)
  (use-package company-lsp :ensure t :commands company-lsp)
  (use-package eglot :ensure t)
  (use-package helm-lsp :commands helm-lsp-workspace-symbol)
#+end_src

** Hydra

#+begin_src emacs-lisp :results silent
  (pretty-hydra-define hydra-lsp (:exit t :hint nil :quit-key "q")
    ("Finding" (("d" lsp-find-declaration             "find declaration")
                ("D" lsp-ui-peek-find-definitions     "peek find declaration")
                ("R" lsp-ui-peek-find-references      "peek find refs")
                ("i" lsp-ui-peek-find-implementation  "peek find implementation")
                ("t" lsp-find-type-defition           "find type definition"))

     "Misc" (("f" lsp-format-buffer                   "format buffer")
             ("m" lsp-ui-imenu                        "ui menu")
             ("x" lsp-execute-code-action             "execeute code action")
             ("s" lsp-signature-help                  "sig help")
             ("o" lsp-describe-thing-at-point         "describe thing at point")
             ("r" lsp-rename                          "rename"))

     "Sesion" (("M-s" lsp-describe-session            "describe session")
               ("M-r" lsp-restart-workspace           "restart workspace")
               ("S" lsp-shutdown-workspace            "shutdown workspace"))))

  (define-key lsp-mode-map (kbd "C-c l") 'hydra-lsp/body)
#+end_src

* Python

#+begin_src emacs-lisp :results silent
  (use-package python
    :defer t
    :hook python-mode-hook)

  (use-package pydoc :ensure t)
  (use-package helm-pydoc :ensure t)
  (use-package elpy :ensure t)
  (use-package blacken :ensure t)

  (use-package pyvenv
    :ensure t
    :config
    (setenv "WORKON_HOME" "~/.pyenv/versions"))

  (defun ddavis/get-pyvenv-name ()
    "grab the name of the active pyvenv (nil if not defined)"
    (when pyvenv-virtual-env
      (car (last (split-string (directory-file-name pyvenv-virtual-env) "/")))))

  (defun ddavis/py-auto-lsp ()
    "turn on lsp mode in a Python project by trying to
  automatically determine which pyenv virtual environment to
  activate based on the project name"
    (interactive)
    (if (and pyvenv-virtual-env
             (file-directory-p pyvenv-virtual-env)
             (string= projectile-project-name (ddavis/get-pyvenv-name)))
        (lsp)
      (pyvenv-workon (projectile-project-name))
      (if (file-directory-p pyvenv-virtual-env)
          (lsp)
        (progn
          (message (format "%s does not exist, set manually"
                           pyvenv-virtual-env))
          (call-interactively #'pyvenv-workon)
          (lsp)))))

  (defun ddavis/eglot-prep-for-python ()
    "prepare python eglot setup"
    (interactive)
    (setq company-backends (cons 'company-capf (remove 'company-capf company-backends)))
    (add-to-list 'eglot-server-programs '(python-mode . ("pyls"))))
#+end_src

* C++

#+begin_src emacs-lisp :results silent
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.icc\\'" . c++-mode))

  (defun ddavis/eglot-prep-for-cpp ()
    "enable variables and hooks for eglot cpp IDE"
    (interactive)
    (require 'eglot)
    (setq company-backends (cons 'company-capf (remove 'company-capf company-backends)))
    (add-to-list 'eglot-server-programs `((c++-mode cc-mode) ,ddavis-v-clangd-exe)))

  (use-package clang-format
    :ensure t
    :config
    (setq clang-format-executable ddavis-v-clang-format-exe))

  (use-package modern-cpp-font-lock
    :ensure t
    :hook (c++-mode . modern-c++-font-lock-mode))
#+end_src

* TeX and PDF
** TeX

#+begin_src emacs-lisp :results silent
  (use-package auctex
    :mode ("\\.tex\\'" . TeX-latex-mode)
    :init
    (setq font-latex-fontify-sectioning 'color
          font-latex-fontify-script nil
          TeX-source-correlate-mode 'synctex
          TeX-source-correlate-start-server t)
    (setq-default TeX-master nil)
    :config
    (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))

  (use-package reftex
    :after auctex
    :hook (LaTeX-mode . reftex-mode))

  (use-package helm-bibtex :ensure t)
  (use-package company-bibtex :ensure t)
#+end_src

** PDF

#+begin_src emacs-lisp :results silent
  (when ddavis-v-is-cc7
    (setenv "PKG_CONFIG_PATH" "/usr/lib64/pkgconfig")
    (use-package pdf-tools
      :config
      (pdf-tools-install)
      (setq-default pdf-view-display-size 'fit-page)
      (setq TeX-view-program-selection '((output-pdf "PDF Tools")))))
#+end_src

** Thesis

  #+begin_src emacs-lisp :results silent
    (defvar ddavis-v-thesis-bib nil)
    (defvar ddavis-v-thesis-file nil)

    (defun ddavis/work-on-thesis ()
      (interactive)
      (when (file-exists-p "~/Desktop/thesis/biblio/refs.bib")
        (setq ddavis-v-thesis-file "~/Desktop/thesis/dissertation.tex"
              ddavis-v-thesis-bib "~/Desktop/thesis/biblio/refs.bib"))
      (when (file-exists-p "~/Documents/thesis/biblio/refs.bib")
        (setq ddavis-v-thesis-file "~/Documents/thesis/dissertation.tex"
              ddavis-v-thesis-bib "~/Documents/thesis/biblio/refs.bib"))
      (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
      (add-to-list 'company-backends 'company-bibtex)
      (setq company-bibtex-bibliography `(,ddavis-v-thesis-bib)
            bibtex-completion-bibliography `(,ddavis-v-thesis-bib)
            reftex-plug-into-AUCTeX t)
      (find-file ddavis-v-thesis-file))

    (when ddavis-v-is-mac
      (global-set-key (kbd "s-t") #'ddavis/work-on-thesis))
  #+end_src

* Spell

Add some flyspell hooks for a few modes.

#+begin_src emacs-lisp :results silent
  (use-package flyspell
    :hook ((org-mode . flyspell-mode)
           (LaTeX-mode . flyspell-mode)
           (markdown-mode . flyspell-mode)
           (message-mode . flyspell-mode)
           (mu4e-compose-mode .flyspell-mode)))
#+end_src

* Auth and password-store

Setting up authentication with encryption

#+begin_src emacs-lisp :results silent
  (use-package auth-source
    :config
    (setq auth-sources '("~/.emacs.d/.authinfo.gpg")))

  (use-package epa-file
    :config
    (epa-file-enable)
    (if ddavis-v-is-mac
        (custom-set-variables '(epg-gpg-program "/usr/local/bin/gpg"))
      (custom-set-variables '(epg-gpg-program "/usr/bin/gpg2"))))

  (use-package password-store
    :when ddavis-v-enable-irc
    :commands (password-store-copy
               password-store-get
               password-store-edit
               password-store-insert)
    :ensure t)
#+end_src

* Misc
** Bindings

#+begin_src emacs-lisp :results silent
  (global-unset-key (kbd "C-d"))

  (defun ddavis/open-init ()
    (interactive)
    (find-file "~/.emacs.d/dot-emacs/emacs-init.org"))

  (use-package emacs
    :bind (("C-c q" . auto-fill-mode)
           ("C-x \\" . ddavis/toggle-window-split)
           ("C-d f" . ddavis/open-init)))
#+end_src

** Random

#+begin_src emacs-lisp :results silent
  ;; misc seq's
  (setq ring-bell-function 'ignore)
  (setq echo-keystrokes 0.001)
  (setq inhibit-startup-screen t)
  (setq-default show-paren-delay 0)
  (setq-default indent-tabs-mode nil)

  ;; we don't like Emacs backups
  (setq auto-save-list-file-prefix nil
        create-lockfiles nil
        auto-save-list-file-prefix nil
        backup-by-copying t
        backup-directory-alist '(("." . "~/.saves"))
        delete-old-versions t
        kept-new-versions 3
        kept-old-versions 2
        version-control t)

  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (show-paren-mode 1)

  ;; delete trailing whitepace in a few modes
  (mapc
   (lambda (language-mode-hook)
     (add-hook language-mode-hook
               (lambda ()
                 (add-to-list 'write-file-functions 'delete-trailing-whitespace))))
   '(text-mode-hook
     c-mode-common-hook
     emacs-lisp-mode-hook
     python-mode-hook
     markdown-mode-hook
     bash-mode-hook
     sh-mode-hook
     cmake-mode-hook
     fundamental-mode-hook
     LaTeX-mode-hook))
#+end_src

** Some packages

#+begin_src emacs-lisp :results silent
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1))

  (use-package yasnippet-snippets :ensure t)
  (use-package deadgrep :ensure t)
  (use-package cmake-mode :ensure t)

  (use-package which-key
    :ensure t
    :hook (after-init . which-key-mode))


  (use-package iedit
    :ensure t
    :bind ("C-c ;" . 'iedit-mode))

  (use-package markdown-mode
    :ensure t
    :mode ("\\.md\\'" . markdown-mode))

  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml\\'" . yaml-mode)
           ("\\.yaml\\'" . yaml-mode)))

  (use-package ace-window
    :ensure t
    :bind ("M-o" . 'ace-window))
#+end_src

** Modes

#+begin_src emacs-lisp :results silent
  (use-package emacs
    :mode (("mbsyncrc" . conf-mode)
           ("msmtprc" . conf-mode)))
#+end_src

* Elfeed

#+begin_src emacs-lisp :results silent
  (use-package elfeed
    :ensure t
    :bind ("C-x w" . 'elfeed)
    :config
    (setq shr-use-fonts nil)
    (setq elfeed-feeds
          '(("https://planet.scipy.org/feed.xml" python)
            ("https://planet.emacslife.com/atom.xml" emacs)
            ("https://ddavis.io/index.xml" blog)
            ("http://pragmaticemacs.com/feed/" emacs)
            ("http://feeds.podtrac.com/zKq6WZZLTlbM" nyt podcast)
            ("https://www.npr.org/rss/podcast.php?id=510310" npr podcast)
            ("https://www.npr.org/rss/podcast.php?id=510318" npr podcast)))


    ;; Entries older than 3 weeks are marked as read
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :before "3 weeks ago"
                                  :remove 'unread))

    (setq-default elfeed-search-filter "@10-days-ago"))

  (defvar ddavis-v-podcast-speed "1.33"
    "mpv --speed argument for podcasts")

  (defun ddavis/elfeed-play-enclosure-with-mpv ()
    "Play enclosure link with mpv."
    (interactive)
    (let ((speed ddavis-v-podcast-speed)
          (podcast-link (nth 0 (car (elfeed-entry-enclosures elfeed-show-entry)))))
      (message "Opening %s with with mpv..." podcast-link)
      (start-process "elfeed-mpv" nil "mpv"
                     "--speed" speed
                     podcast-link)))

#+end_src

* Browser

#+begin_src emacs-lisp :results silent
  (when ddavis-v-is-cc7
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "/home/ddavis/Software/localbase/bin/firefox"))
#+end_src

* Dired

#+begin_src emacs-lisp :results silent
  (use-package dired
    :bind (:map dired-mode-map
                ("q" . kill-current-buffer))
    :hook (dired-mode . hl-line-mode))

  (use-package all-the-icons :ensure t)

  (use-package all-the-icons-dired
    :ensure t
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package diredfl
    :ensure t
    :hook (dired-mode . diredfl-mode))
#+end_src

** Hydra

#+begin_src emacs-lisp :results silent
  (defhydra hydra-dired (:hint nil :color pink)
    "
    _+_ mkdir          _v_ view         _m_ mark           _(_ details        _i_ insert-subdir  wdired
    _C_ copy           _O_ view other   _U_ unmark all     _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
    _D_ delete         _o_ open other   _u_ unmark         _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
    _R_ rename         _M_ chmod        _t_ toggle         _g_ revert buf     _e_ ediff          C-c ESC : abort
    _Y_ rel symlink    _G_ chgrp        _E_ extension mark _s_ sort           _=_ pdiff
    _S_ symlink        ^ ^              _F_ find marked    _._ toggle hydra   \\ flyspell
    _r_ rsync          ^ ^              ^ ^                ^ ^                _?_ summary
    _z_ compress-file  _A_ find regexp
    _Z_ compress       _Q_ repl regexp

    T - tag prefix
    "
    ("\\" dired-do-ispell)
    ("(" dired-hide-details-mode)
    (")" dired-omit-mode)
    ("+" dired-create-directory)
    ("=" diredp-ediff)         ;; smart diff
    ("?" dired-summary)
    ("$" diredp-hide-subdir-nomove)
    ("A" dired-do-find-regexp)
    ("C" dired-do-copy)        ;; Copy all marked files
    ("D" dired-do-delete)
    ("E" dired-mark-extension)
    ("e" dired-ediff-files)
    ("F" dired-do-find-marked-files)
    ("G" dired-do-chgrp)
    ("g" revert-buffer)        ;; read all directories again (refresh)
    ("i" dired-maybe-insert-subdir)
    ("l" dired-do-redisplay)   ;; relist the marked or singel directory
    ("M" dired-do-chmod)
    ("m" dired-mark)
    ("O" dired-display-file)
    ("o" dired-find-file-other-window)
    ("Q" dired-do-find-regexp-and-replace)
    ("R" dired-do-rename)
    ("r" dired-do-rsynch)
    ("S" dired-do-symlink)
    ("s" dired-sort-toggle-or-edit)
    ("t" dired-toggle-marks)
    ("U" dired-unmark-all-marks)
    ("u" dired-unmark)
    ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
    ("w" dired-kill-subdir)
    ("Y" dired-do-relsymlink)
    ("z" diredp-compress-this-file)
    ("Z" dired-do-compress)
    ("q" nil)
    ("C-g" nil :color blue)
    ("." nil :color blue))

  (define-key dired-mode-map "." 'hydra-dired/body)
#+end_src

* Email
** sending mail

#+begin_src emacs-lisp :results silent
  (setq message-send-mail-function 'message-send-mail-with-sendmail
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-kill-buffer-on-exit t)

  (setq sendmail-program ddavis-v-sendmail-program)

  (defun ddavis/reset-standard-name-and-email ()
    (interactive)
    (setq user-mail-address "ddavis@ddavis.io"
          user-email-address "ddavis@ddavis.io"
          user-full-name "Doug Davis"))
#+end_src

** indexing mail with mu4e

My [[https://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] setup

#+begin_src emacs-lisp :results silent
  (defun ddavis/mu4e-jump-via-helm ()
    (interactive)
    (let ((maildir (helm-comp-read "Maildir: " (mu4e-get-maildirs))))
      (mu4e-headers-search (format "maildir:\"%s\"" maildir))))

  (defun mu4e-action-view-in-w3m ()
    "View the body of the message in emacs w3m."
    (interactive)
    (w3m-browse-url (concat "file://"
                            (mu4e~write-body-to-html (mu4e-message-at-point t)))))

  (defun ddavis/mu4e-toggle-gnus ()
    (interactive)
    (setq mu4e-view-use-gnus (not mu4e-view-use-gnus)))

  (with-eval-after-load "mm-decode"
    (add-to-list 'mm-discouraged-alternatives "text/html")
    (add-to-list 'mm-discouraged-alternatives "text/richtext"))

  (use-package mu4e
    :when ddavis-v-enable-mu4e
    :load-path ddavis-v-mu4e-dir
    :commands (mu4e mu4e-update-mail-and-index)
    :bind (("C-c 4" . mu4e)
           :map mu4e-headers-mode-map
           ("j" . ddavis/mu4e-jump-via-helm)
           ("d" . mu4e-headers-mark-for-delete)
           ("D" . mu4e-headers-mark-for-trash)
           :map mu4e-main-mode-map
           ("j" . ddavis/mu4e-jump-via-helm)
           :map mu4e-view-mode-map
           ("d" . mu4e-view-mark-for-delete)
           ("D" . mu4e-view-mark-for-trash)
           ("M" . mu4e-action-view-in-w3m)
           ("j" . ddavis/mu4e-jump-via-helm))
    :config
    (setq mu4e-mu-binary ddavis-v-mu-exe
          mu4e-change-filenames-when-moving t
          mu4e-get-mail-command "true"
          mu4e-update-interval 120
          mu4e-maildir "~/.mail"
          mu4e-confirm-quit nil
          mu4e-context-policy 'pick-first
          mu4e-user-mail-address-list '()
          mu4e-attachment-dir (expand-file-name "~/Downloads/")
          mu4e-change-filenames-when-moving t)

    (setq mu4e-compose-reply-ignore-address
          '("notifications@github\\.com"
            "ddavis@ddavis\\.io"
            "ddavis@phy\\.duke\\.edu"
            "douglas\\.davis\\.092@gmail\\.com"
            "douglas\\.davis@duke\\.edu"
            "douglas\\.davis@cern\\.ch"
            "ddavis@cern\\.ch"))

    (setq w3m-default-desplay-inline-images t)

    (setq mu4e-contexts
          `( ,(make-mu4e-context
               :name "cern"
               :enter-func (lambda () (mu4e-message "Entering CERN context"))
               :leave-func (lambda () (ddavis/reset-standard-name-and-email))
               :match-func (lambda (msg)
                             (when msg
                               (string-match-p "^/cern" (mu4e-message-field msg :maildir))))
               :vars '( ( user-mail-address      . "ddavis@cern.ch" )
                        ( user-email-address     . "ddavis@cern.ch" )
                        ( user-full-name         . "Doug Davis" )
                        ( mu4e-trash-folder      . "/cern/Trash" )
                        ( mu4e-sent-folder       . "/cern/Sent" )
                        ( mu4e-drafts-folder     . "/cern/Drafts" )
                        ( mu4e-reply-to-address  . "ddavis@cern.ch" )))

             ,(make-mu4e-context
               :name "duke"
               :enter-func (lambda () (mu4e-message "Entering Duke context"))
               :leave-func (lambda () (ddavis/reset-standard-name-and-email))
               :match-func (lambda (msg)
                             (when msg
                               (string-match-p "^/duke" (mu4e-message-field msg :maildir))))
               :vars '( ( user-mail-address       . "ddavis@phy.duke.edu" )
                        ( user-email-address      . "ddavis@phy.duke.edu" )
                        ( user-full-name          . "Doug Davis" )
                        ( mu4e-trash-folder       . "/duke/Trash" )
                        ( mu4e-sent-folder        . "/duke/Sent" )
                        ( mu4e-drafts-folder      . "/duke/Drafts" )
                        ( mu4e-reply-to-address   . "ddavis@phy.duke.edu" )))))

    (when (or ddavis-v-is-mac ddavis-v-is-cc7)
      (add-to-list 'mu4e-contexts
                   (make-mu4e-context
                    :name "gmail"
                    :enter-func (lambda () (mu4e-message "Entering Gmail context"))
                    :leave-func (lambda () (ddavis/reset-standard-name-and-email))
                    :match-func (lambda (msg)
                                  (when msg
                                    (string-match-p "^/gmail" (mu4e-message-field msg :maildir))))
                    :vars '( ( user-mail-address           . "douglas.davis.092@gmail.com" )
                             ( user-email-address          . "douglas.davis.092@gmail.com" )
                             ( user-full-name              . "Doug Davis" )
                             ( mu4e-trash-folder           . "/gmail/_blackhole" )
                             ( mu4e-sent-folder            . "/gmail/[Gmail]/Sent Mail" )
                             ( mu4e-drafts-folder          . "/gmail/_blackhole" )
                             ( mu4e-reply-to-address       . "douglas.davis.092@gmail.com" ))))
      (add-to-list 'mu4e-contexts
                   (make-mu4e-context
                    :name "fastmail"
                    :enter-func (lambda () (mu4e-message "Entering FastMail context"))
                    :leave-func (lambda () (mu4e-message "Leaving FastMail context"))
                    :match-func (lambda (msg)
                                  (when msg
                                    (string-match-p "^/fastmail" (mu4e-message-field msg :maildir))))
                    :vars '( ( user-mail-address      . "ddavis@ddavis.io" )
                             ( user-email-address     . "ddavis@ddavis.io" )
                             ( user-full-name         . "Doug Davis" )
                             ( mu4e-trash-folder      . "/fastmail/Trash" )
                             ( mu4e-sent-folder       . "/fastmail/Sent" )
                             ( mu4e-drafts-folder     . "/fastmail/Drafts" )
                             ( mu4e-reply-to-address  . "ddavis@ddavis.io" )))))


    (setq mu4e-bookmarks ())
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Unread short"
                  :query "flag:unread and (m:/duke* or m:/cern* or m:/fastmail/INBOX or m:/gmail/INBOX*)"
                  :key ?u))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Recent personal"
                  :query "date:14d..now and (m:/fastmail/INBOX or m:/gmail/INBOX*)"
                  :key ?p))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Unread all"
                  :query "flag:unread and not flag:trashed"
                  :key ?U))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "INBOXes"
                  :query "m:/duke/INBOX or m:/cern/INBOX or m:/fastmail/INBOX or m:/gmail/INBOX"
                  :key ?i))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Last day's work"
                  :query "date:1d..now and not m:/fastmail* and not m:/gmail*"
                  :key ?w))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Recent work"
                  :query "date:3d..now and not m:/fastmail* and not m:/gmail*"
                  :key ?r))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Duke recent"
                  :query "date:5d..now and m:/duke*"
                  :key ?d))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "CERN recent"
                  :query "date:2d..now and m:/cern*"
                  :key ?c))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Emacs"
                  :query "m:/fastmail/Lists/emacs-devel or m:/fastmail/Lists/help-gnu-emacs"
                  :key ?e))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Last 1 day"
                  :query "date:1d..now"
                  :key ?1))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Last 3 days"
                  :query "date:3d..now"
                  :key ?3))
    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Last 7 days"
                  :query "date:1w..now"
                  :key ?7)))
#+end_src

* macOS

Some configuration specific to using Emacs on macOS.

#+begin_src emacs-lisp :results silent
  (defun ddavis/delete-frame-or-window ()
    "if we have multiple frames delete the current one, if only one
  delete the window; this is really just for binding Command+w to
  behave similar to other macOS applications."
    (interactive)
    (if (< (count-windows) 2)
        (delete-frame)
      (delete-window)))

  (defun ddavis/switch-to-or-start-gnus ()
    "if we have a '*Group*' buffer go and and switch to it; if not
  spin up gnus. just for binding to s-u on macOS."
    (interactive)
    (if (get-buffer "*Group*")
        (switch-to-buffer "*Group*")
      (gnus)))

  (when (memq window-system '(mac ns))
    (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    (setq-default ns-alternate-modifier 'meta)
    (setq-default mac-option-modifier 'meta)
    (setq-default ns-right-alternate-modifier nil)
    (setq-default ns-command-modifier 'super)
    (setq-default mac-command-modifier 'super)
    (setq-default ns-function-modifier 'hyper)
    (setq-default mac-function-modifier 'hyper)
    (global-set-key [(meta shift up)]  'ddavis/move-line-up)
    (global-set-key [(meta shift down)]  'ddavis/move-line-down))

  (use-package emacs
    :if ddavis-v-is-mac
    :bind (("s-/" . previous-buffer)
           ("s-\\" . ddavis/toggle-window-split)
           ("s-1" . delete-other-windows)
           ("s-2" . split-window-below)
           ("s-3" . split-window-right)
           ("s-5" . projectile-find-file-in-known-projects)
           ("s-4" . mu4e)
           ("s-d" . ddavis/open-init)
           ("s-b" . helm-buffers-list)
           ("s-f" . helm-find-files)
           ("s-g" . magit-status)
           ("s-o" . other-window)
           ("s-p" . helm-projectile)
           ("s-r" . ddavis/helm-project-search)
           ("s-u" . ddavis/switch-to-or-start-gnus)
           ("s-w" . ddavis/delete-frame-or-window)))

#+end_src

* IRC

I haven't really been able to make up my mind on using the builtin
Emacs IRC client [[https://www.emacswiki.org/emacs/ERC][ERC]] or the third party client [[https://github.com/jorgenschaefer/circe][Circe]]. This configures
usage of both.

** Circe Utilities

#+begin_src emacs-lisp :results silent
  (defun ddavis/irc-pw-freenode (server)
    (password-store-get "Freenode"))

  (defun ddavis/irc-pw-gitter (server)
    (password-store-get "Gitter"))

  (defun circe-network-connected-p (network)
    "Return non-nil if there's any Circe server-buffer whose
    `circe-server-netwok' is NETWORK."
    (catch 'return
      (dolist (buffer (circe-server-buffers))
        (with-current-buffer buffer
          (if (string= network circe-server-network)
              (throw 'return t))))))

  (defun circe-maybe-connect (network)
    "Connect to NETWORK, but ask user for confirmation if it's
    already been connected to."
    (interactive "sNetwork: ")
    (if (or (not (circe-network-connected-p network))
            (y-or-n-p (format "Already connected to %s, reconnect?" network)))
        (circe network)))

  (defun ddavis/circe-prompt ()
    (lui-set-prompt
     (propertize (format "%s >>> " (buffer-name)) 'face 'circe-prompt-face)))
#+end_src

** Circe Setup

#+begin_src emacs-lisp :results silent
  (use-package circe
    :when ddavis-v-enable-irc
    :ensure t
    :hook (circe-chat-mode . ddavis/circe-prompt)
    :config
    (setq circe-network-options
          `(("Freenode"
             :nick "ddavis"
             :nickserv-password ddavis/irc-pw-freenode
             :nickserv-identify-confirmation "Freenode password accepted for ddavis"
             :tls t)
            ("Gitter"
             :server-buffer-name "Gitter"
             :host "irc.gitter.im"
             :port "6697"
             :nick "douglasdavis"
             :pass ddavis/irc-pw-gitter
             :tls t)))
    (require 'circe-color-nicks)
    (setq circe-color-nicks-pool-type
          '("#fb4934" "#b8bb26" "#fabd2f" "#83a598" "#d3869b" "#8ec07c" "#fe8019"
            "#cc241d" "#98971a" "#d79921" "#458588" "#b16286" "#689d6a" "#d65d0e"))
    (enable-circe-color-nicks)
    (setq circe-use-cycle-completion t
          circe-reduce-lurker-spam t
          circe-format-say "<{nick}> {body}"
          lui-fill-type 19
          lui-fill-column 77
          circe-color-nicks-everywhere t)
    (setq helm-mode-no-completion-in-region-in-modes
          '(circe-channel-mode
            circe-query-mode
            circe-server-mode))
    (setq circe-default-part-message
          (concat "Closed Circe (" circe-version ") buffer in GNU Emacs (" emacs-version ")"))
    (setq circe-default-quit-message
          (concat "Quit Circe (" circe-version ") in GNU Emacs (" emacs-version ")")))

  (use-package helm-circe
    :when ddavis-v-enable-irc
    :after circe
    :ensure t
    :bind (:map helm-command-map ("i" . helm-circe)))
#+end_src

** ERC Utilities

#+begin_src emacs-lisp :results silent
  (defvar ddavis-nick-face-list '()
    "See https://www.emacswiki.org/emacs/ErcNickColors#toc1")

  (defvar ddavis-erc-colors-list
    '("#fb4934" "#b8bb26" "#fabd2f" "#83a598" "#d3869b" "#8ec07c" "#fe8019"
      "#cc241d" "#98971a" "#d79921" "#458588" "#b16286" "#689d6a" "#d65d0e")
    "See https://www.emacswiki.org/emacs/ErcNickColors#toc1")

  (defun ddavis/build-nick-face-list ()
    "See https://www.emacswiki.org/emacs/ErcNickColors#toc1"
    (setq i -1)
    (setq ddavis-nick-face-list
          (mapcar
           (lambda (COLOR)
             (setq i (1+ i))
             (list (custom-declare-face
                    (make-symbol (format "erc-nick-face-%d" i))
                    (list (list t (list :foreground COLOR)))
                    (format "Nick face %d" i))))
           ddavis-erc-colors-list)))

  (defun ddavis/erc-insert-modify-hook ()
    "See https://www.emacswiki.org/emacs/ErcNickColors#toc1"
    (if (null ddavis-nick-face-list) (ddavis/build-nick-face-list))
    (save-excursion
      (goto-char (point-min))
      (if (looking-at "<\\([^>]*\\)>")
          (let ((nick (match-string 1)))
            (put-text-property (match-beginning 1) (match-end 1)
                               'face (nth
                                      (mod (string-to-number
                                            (substring (md5 nick) 0 4) 16)
                                           (length ddavis-nick-face-list))
                                      ddavis-nick-face-list))))))

  (defun ddavis/erc-notify (nickname message)
    "Displays a notification message for ERC."
    (let* ((channel (buffer-name))
           (nick (erc-hl-nicks-trim-irc-nick nickname))
           (title (if (string-match-p (concat "^" nickname) channel)
                      nick
                    (concat nick " (" channel ")")))
           (msg (s-trim (s-collapse-whitespace message))))
      (alert (concat nick ": " msg) :title title)))
#+end_src

** ERC Setup

#+begin_src emacs-lisp :results silent
  (use-package erc
    :when ddavis-v-enable-irc
    :hook ((erc-notify . ddavis/erc-notify)
           (erc-insert-modify . ddavis/erc-insert-modify-hook))
    :custom-face (erc-notice-face ((t (:foreground "#ebcb8b"))))
    :config
    (setq erc-user-full-name "Doug Davis"
          erc-prompt-for-password nil
          erc-track-enable-keybindings nil
          erc-kill-server-buffer-on-quit t
          erc-kill-buffer-on-part t
          erc-fill-function 'erc-fill-static
          erc-fill-static-center 19
          erc-prompt (lambda () (concat (buffer-name) " >>>"))))

  (use-package erc-track
    :when ddavis-v-enable-irc
    :after erc
    :config
    (erc-track-mode t)
    (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                    "324" "329" "332" "333" "353" "477")))
#+end_src

* Helpful

#+begin_src emacs-lisp :results silent
  (use-package help-mode
    :bind
    (:map help-mode-map
          ("q" . kill-buffer-and-window)))

  (use-package helpful
    :ensure t
    :bind (("C-h f" . #'helpful-callable)
           ("C-h v" . #'helpful-variable)
           ("C-h k" . #'helpful-key)
           :map helpful-mode-map
           ("q" . kill-buffer-and-window)))
#+end_src

* Tramp

#+begin_src emacs-lisp :results silent
  (use-package tramp
    :defer 5
    :config
    (setq tramp-default-method "ssh"))

  (defun ddavis/cleanup-tramp ()
    (interactive)
    (tramp-cleanup-all-buffers)
    (tramp-cleanup-all-connections)
    (find-file "~/."))
#+end_src

* vterm

#+begin_src emacs-lisp :results silent
  (use-package vterm :when ddavis-v-is-cc7 :ensure t)

  (defun ddavis/remote-vterm (user-at-machine)
    (interactive "sMachine: ")
    (let ((default-directory (format "/ssh:%s:~/." user-at-machine)))
      (vterm-toggle-cd)))
#+end_src

* End

end
